npm install xlsx
PORT=5000
MONGO_DB_USER=mohini
MONGO_DB_PASSWORD=mohiniraut
MONGO_DB_DATABASE=vvmcelectrical
JWT_SECRET=MERNSECRET
API=https://lightbillbackend.saavi.co.in
EMAIL=mohinimraut7@gmail.com
PASSWORD=MohiniRaut@75
BASEURL=https://lightbillbackend.saavi.co.in
AAPPASSWORD=enpz swmp tycr ryhh
-----------------------
API=https://lightbillbackend.saavi.co.in
BASEURL=https://lightbillbackend.saavi.co.in
-----------------

BASEURL=http://localhost:5000
API=http://localhost:5000





BASEURL=http://localhost:5000
API=http://localhost:5000

API=https://lightbillbackend.saavi.co.in
BASEURL=https://lightbillbackend.saavi.co.in




================

vazejeet16@gmail.com
===========================================

exports.addRemarkReports = async (req, res) => {
    try {
        const {
            userId,
            remark,
            role,
            signature,
            ward,
            formType,
            pdfData,
            seleMonth,
            wardName,
            mode
        } = req.body;

        console.log("req.body", req.body.wardName);
        const userWard = req.body.ward;
       
        const missingFields = [];
        if (!role) missingFields.push("role");
        if (!remark) missingFields.push("remark");
        if (!formType) missingFields.push("formType");
        if (!seleMonth) missingFields.push("seleMonth");
        if (!ward) missingFields.push("ward");

        if (missingFields.length > 0) {
            return res.status(400).json({
                message: `Missing required fields: ${missingFields.join(", ")}`
            });
        }

       
        const formNumber = await generateFormNumber(formType);
        let document = null;

       
        if (req.file) {
            document = {
                formType,
                formNumber,
                pdfFile: req.file.path,
                uploadedAt: new Date(),
                seleMonth
            };
        } else if (pdfData) {
            const pdfFilePath = saveBase64File(pdfData, formNumber);
            if (pdfFilePath) {
                document = {
                    formType,
                    formNumber,
                    pdfFile: pdfFilePath,
                    uploadedAt: new Date(),
                    seleMonth
                };
            } else {
                return res.status(400).json({
                    message: "Invalid base64 PDF data."
                });
            }
        } else {
            return res.status(400).json({
                message: "No file or PDF data provided."
            });
        }

      
        const createRemark = ({ userId,ward,role, remark, signature, document,userWard  }) => {
            const remarkObj = {
                userId: new mongoose.Types.ObjectId(userId),
                ward,
                userWard,
                role,
                remark,
                signature,
                date: new Date()
            };

          
           
if (document && role !== "Lipik") {
    const lipikRemark = report.reportingRemarks.find(r => r.role === "Lipik");

    if (lipikRemark) {
        lipikRemark.documents = lipikRemark.documents || [];

        const docIndex = lipikRemark.documents.findIndex(doc => doc.formType === formType);

        if (mode === "edit") {
            if (docIndex !== -1) {
                const existingDoc = lipikRemark.documents[docIndex];

                lipikRemark.documents[docIndex] = {
                    ...existingDoc,
                    ...document,
                    uploadedAt: new Date(),
                    signatures: {
                        ...(existingDoc.signatures || {}),
                        [role]: signature  // Add/update the current role's signature
                    }
                };
            } else {
                lipikRemark.documents.push({
                    ...document,
                    uploadedAt: new Date(),
                    signatures: {
                        [role]: signature
                    }
                });
            }
        } else {
            const alreadyExists = lipikRemark.documents.some(doc => doc.formType === formType);
            if (!alreadyExists) {
                lipikRemark.documents.push({
                    ...document,
                    uploadedAt: new Date(),
                    signatures: {
                        [role]: signature
                    }
                });
            }
        }
    } else {
        return res.status(400).json({
            message: "Lipik remark not found. Cannot attach document."
        });
    }
}


            return remarkObj;
        };

      
        if (role === "Junior Engineer" && ward === "Head Office" && wardName) {
            let wardReport = await Report.findOne({ seleMonth, ward: wardName });

            if (!wardReport) {
                wardReport = new Report({
                    seleMonth,
                    userWard,
                    ward: wardName,
                    monthReport: seleMonth,
                });
            }

            const jeRemark = {
                userId: new mongoose.Types.ObjectId(userId),
                role: "Junior Engineer",
                ward,
                userWard,
                remark,
                signature,
                date: new Date(),
            };

            const jeExists = wardReport.reportingRemarks.some(r =>
                r.userId.toString() === userId &&
                r.role === "Junior Engineer" &&
                r.remark === remark
            );

            if (!jeExists) {
                wardReport.reportingRemarks.push(jeRemark);
                await wardReport.save();
            }

            return res.status(201).json({
                message: `Junior Engineer remark added to ward ${wardName} successfully.`,
                report: wardReport
            });
        }

      
        let report = await Report.findOne({ seleMonth, ward });

        if (!report) {
            report = new Report({
                seleMonth,
                ward,
                monthReport: seleMonth,
            });
        }

      
        if (report.reportingRemarks.length === 0) {
            // First remark must be from Lipik (specific ward)
            if (role !== "Lipik") {
                return res.status(400).json({
                    message: "The first remark must be from the role 'Lipik'."
                });
            }
        } 
        
        else if (report.reportingRemarks.length === 1) {
            const firstRemark = report.reportingRemarks[0];
        
            // Second remark must be from Junior Engineer (same ward as Lipik, Head Office not allowed)
            if (role !== "Junior Engineer") {
                return res.status(400).json({
                    message: "The second remark must be from the role 'Junior Engineer'."
                });
            }
        
            if (userWard === "Head Office") {
                return res.status(400).json({
                    message: "Junior Engineer from 'Head Office' is not allowed for second remark."
                });
            }
        
            if (userWard !== firstRemark.userWard) {
                return res.status(400).json({
                    message: `Junior Engineer's ward must match Lipik's ward ('${firstRemark.userWard}').`
                });
            }
        }
        
        // -----------------------------------------------------
       
        
        else if (report.reportingRemarks.length === 2) {
            const secondRemark = report.reportingRemarks[1];
        
            // Third remark must be from Junior Engineer (Head Office only)
            if (role !== "Junior Engineer" || ward !== "Head Office") {
                return res.status(400).json({
                    message: "The third remark must be from the role 'Junior Engineer' from 'Head Office'."
                });
            }
        }
        else if (report.reportingRemarks.length === 3) {
            const thirdRemark = report.reportingRemarks[2];
        
            // Fourth remark must be from Accountant
            if (role !== "Accountant") {
                return res.status(400).json({
                    message: "The fourth remark must be from the role 'Accountant'."
                });
            }
        
            // Accountant must match Junior Engineer (Head Office) ward
            if (ward !== thirdRemark.ward) {
                return res.status(400).json({
                    message: `Accountant must belong to same ward as Junior Engineer from Head Office ('${thirdRemark.ward}').`
                });
            }
        }
        else if (report.reportingRemarks.length === 4) {
            const fourthRemark = report.reportingRemarks[3];
        
            // Fifth remark must be from Assistant Municipal Commissioner
            if (role !== "Assistant Municipal Commissioner") {
                return res.status(400).json({
                    message: "The fifth remark must be from the role 'Assistant Municipal Commissioner'."
                });
            }
        
            if (ward !== fourthRemark.ward) {
                return res.status(400).json({
                    message: `Assistant Municipal Commissioner must belong to same ward as Accountant ('${fourthRemark.ward}').`
                });
            }
        }
        else if (report.reportingRemarks.length === 5) {
            const fifthRemark = report.reportingRemarks[4];
        
            // Sixth remark must be from Dy. Municipal Commissioner
            if (role !== "Dy. Municipal Commissioner") {
                return res.status(400).json({
                    message: "The sixth remark must be from the role 'Dy. Municipal Commissioner'."
                });
            }
        
            if (ward !== fifthRemark.ward) {
                return res.status(400).json({
                    message: `Dy. Municipal Commissioner must belong to same ward as Assistant Municipal Commissioner ('${fifthRemark.ward}').`
                });
            }
        }
        else {
            return res.status(400).json({
                message: "Invalid number of remarks or roles."
            });
        }
        

        const index = report.reportingRemarks.findIndex(r =>
            r.userId.toString() === userId &&
            r.role === role &&
            report.ward === ward
        );

        if (index !== -1) {
            const existing = report.reportingRemarks[index];
            existing.remark = remark;
            existing.signature = signature;
            existing.date = new Date();
            existing.documents = existing.documents || [];

            const docIndex = existing.documents.findIndex(doc => doc.formType === formType);

            if (mode === "edit") {
                if (docIndex !== -1) {
                    existing.documents[docIndex] = document;
                } else {
                    existing.documents.push(document);
                }
            } else {
                const alreadyExists = existing.documents.some(doc => doc.formType === formType);
                if (!alreadyExists && document) {
                    existing.documents.push(document);
                }
            }

            report.reportingRemarks[index] = existing;
        } else {
            const newRemark = createRemark({ userId, role,ward,remark, signature, document,userWard });
            report.reportingRemarks.push(newRemark);
        }

        await report.save();

        res.status(201).json({
            message: "Report added/updated successfully.",
            report
        });

    } catch (error) {
        console.error("🚨 Error adding/updating report:", error);
        res.status(500).json({
            message: "An error occurred while adding the report.",
            error: error.message
        });
    }
};
===================
if (role === "Junior Engineer" && ward === "Head Office" && wardName) {
            let wardReport = await Report.findOne({ seleMonth, ward: wardName });

            if (!wardReport) {
                wardReport = new Report({
                    seleMonth,
                    userWard,
                    ward: wardName,
                    monthReport: seleMonth,
                });
            }

            const jeRemark = {
                userId: new mongoose.Types.ObjectId(userId),
                role: "Junior Engineer",
                ward,
                userWard,
                remark,
                signature,
                date: new Date(),
            };

            const jeExists = wardReport.reportingRemarks.some(r =>
                r.userId.toString() === userId &&
                r.role === "Junior Engineer" &&
                r.remark === remark
            );

            if (!jeExists) {
                wardReport.reportingRemarks.push(jeRemark);
                await wardReport.save();
            }

            return res.status(201).json({
                message: `Junior Engineer remark added to ward ${wardName} successfully.`,
                report: wardReport
            });
        }

======================

const mongoose = require('mongoose');

const reportSchema = new mongoose.Schema({
  monthReport: { type: String },
  seleMonth: { type: String },
  ward: { type: String },
    reportingRemarks: [
        {
          userId: { type: mongoose.Schema.Types.ObjectId, ref: "User", required: true },
          role: { type: String }, 
          remark: { type: String }, 
          userWard:{ type: String },
          signature: { type: String },
          date: { type: Date, default: Date.now }, 
          documents: [
            {
                formType: { type: String},
                formNumber: { type: String}, 
                pdfFile: { type: String }, 
                uploadedAt: { type: Date, default: Date.now },
                // seleMonth:{ type: String },
            }
        ]
          
          // seleMonth:{ type: String },
        }
      ],
      
     
}, { timestamps: true }); 

module.exports = mongoose.model('Report', reportSchema);

-----------------------------------------------------
PORT=5000
MONGO_DB_USER=mohini
MONGO_DB_PASSWORD=mohiniraut
MONGO_DB_DATABASE=vvmcelectrical
JWT_SECRET=MERNSECRET
EMAIL=mohinimraut7@gmail.com
PASSWORD=MohiniRaut@75
API=http://localhost:5000
BASEURL=http://localhost:5000
AAPPASSWORD=enpz swmp tycr ryhh

===================================

 // if (role === "Lipik") {
            //     remarkObj.documents = document ? [document] : [];
            // }
// -------------------------------------------------------------------

            // if (document && role !== "Lipik") {
            //     const lipikRemark = report.reportingRemarks.find(r => r.role === "Lipik");
            
            //     if (lipikRemark) {
            //         lipikRemark.documents = lipikRemark.documents || [];
            
            //         const docIndex = lipikRemark.documents.findIndex(doc => doc.formType === formType);
            
            //         if (mode === "edit") {
            //             if (docIndex !== -1) {
            //                 lipikRemark.documents[docIndex] = document;
            //             } else {
            //                 lipikRemark.documents.push(document);
            //             }
            //         } else {
            //             const alreadyExists = lipikRemark.documents.some(doc => doc.formType === formType);
            //             if (!alreadyExists) {
            //                 lipikRemark.documents.push(document);
            //             }
            //         }
            //     } else {
            //         return res.status(400).json({
            //             message: "Lipik remark not found. Cannot attach document."
            //         });
            //     }
            // }
            
// -------------------------------------------------------------

// if (document && role !== "Lipik") {
//     const lipikRemark = report.reportingRemarks.find(r => r.role === "Lipik");

//     if (lipikRemark) {
//         lipikRemark.documents = lipikRemark.documents || [];

//         const docIndex = lipikRemark.documents.findIndex(doc => doc.formType === formType);

//         if (mode === "edit") {
//             if (docIndex !== -1) {
//                 // Overwrite only specific fields, preserve others
//                 lipikRemark.documents[docIndex] = {
//                     ...lipikRemark.documents[docIndex],
//                     ...document,
//                     uploadedAt: new Date()  // optionally update the timestamp
//                 };
//             } else {
//                 lipikRemark.documents.push(document);
//             }
//         } else {
//             const alreadyExists = lipikRemark.documents.some(doc => doc.formType === formType);
//             if (!alreadyExists) {
//                 lipikRemark.documents.push(document);
//             }
//         }
//     } else {
//         return res.status(400).json({
//             message: "Lipik remark not found. Cannot attach document."
//         });
//     }
// }
// -------------------------------------------
bolt.new
------

exports.addRemarkReports = async (req, res) => {
    try {
        const {
            userId,
            remark,
            role,
            signature,
            ward,
            formType,
            pdfData,
            seleMonth,
            wardName,
            mode
        } = req.body;

        let userWard = ward;

        // Validate required fields
        const missingFields = [];
        if (!role) missingFields.push("role");
        if (!remark) missingFields.push("remark");
        if (!formType) missingFields.push("formType");
        if (!seleMonth) missingFields.push("seleMonth");
        if (!ward) missingFields.push("ward");

        if (missingFields.length > 0) {
            return res.status(400).json({
                message: `Missing required fields: ${missingFields.join(", ")}`
            });
        }

        // Process document
        const formNumber = await generateFormNumber(formType);
        let document = null;

        if (req.file) {
            document = {
                formType,
                formNumber,
                pdfFile: req.file.path,
                uploadedAt: new Date(),
                seleMonth,
                approvedBy: []
            };
        } else if (pdfData) {
            const pdfFilePath = saveBase64File(pdfData, formNumber);
            if (!pdfFilePath) {
                return res.status(400).json({ message: "Invalid PDF data" });
            }
            document = {
                formType,
                formNumber,
                pdfFile: pdfFilePath,
                uploadedAt: new Date(),
                seleMonth,
                approvedBy: []
            };
        }

        // Handle Head Office Junior Engineer
        if (role === "Junior Engineer" && ward === "Head Office" && wardName) {
            let targetWardReport = await Report.findOne({ seleMonth, ward: wardName });
            if (!targetWardReport) {
                return res.status(400).json({
                    message: "Report not found for target ward"
                });
            }

            const validation = validateWorkflowStep(
                wardName,
                role,
                ward,
                targetWardReport.reportingRemarks
            );

            if (!validation.valid) {
                return res.status(400).json({ message: validation.message });
            }

            const newRemark = {
                userId: new mongoose.Types.ObjectId(userId),
                role,
                ward,
                userWard,
                remark,
                signature,
                date: new Date()
            };

            targetWardReport.reportingRemarks.push(newRemark);
            await targetWardReport.save();

            return res.status(200).json({
                message: "Head Office approval added successfully",
                report: targetWardReport
            });
        }

        // Regular ward processing
        let report = await Report.findOne({ seleMonth, ward });
        if (!report) {
            if (role !== "Lipik") {
                return res.status(400).json({
                    message: "First remark must be from Lipik"
                });
            }
            report = new Report({
                seleMonth,
                ward,
                monthReport: seleMonth,
                reportingRemarks: []
            });
        }

        // Validate workflow step
        const validation = validateWorkflowStep(
            ward,
            role,
            ward,
            report.reportingRemarks
        );

        if (!validation.valid) {
            return res.status(400).json({ message: validation.message });
        }

        // Add or update remark
        const remarkIndex = report.reportingRemarks.findIndex(r =>
            r.userId.toString() === userId &&
            r.role === role &&
            r.ward === ward
        );

        const remarkData = {
            userId: new mongoose.Types.ObjectId(userId),
            role,
            ward,
            userWard,
            remark,
            signature,
            date: new Date(),
            documents: []
        };

        if (role === "Lipik" && document) {
            remarkData.documents.push(document);
        }

        if (remarkIndex === -1) {
            report.reportingRemarks.push(remarkData);
        } else {
            report.reportingRemarks[remarkIndex] = {
                ...report.reportingRemarks[remarkIndex],
                ...remarkData
            };
        }

        await report.save();

        res.status(200).json({
            message: "Report updated successfully",
            report
        });

    } catch (error) {
        console.error("Error:", error);
        res.status(500).json({
            message: "An error occurred",
            error: error.message
        });
    }
};
==========================
exports.addRemarkReports = async (req, res) => {
    try {
        const {
            userId,
            remark,
            role,
            signature,
            ward,
            formType,
            pdfData,
            seleMonth,
            wardName,
            mode
        } = req.body;

        let userWard = ward;

        const missingFields = [];
        if (!role) missingFields.push("role");
        if (!remark) missingFields.push("remark");
        if (!formType) missingFields.push("formType");
        if (!seleMonth) missingFields.push("seleMonth");
        if (!ward) missingFields.push("ward");

        if (missingFields.length > 0) {
            return res.status(400).json({
                message: `Missing required fields: ${missingFields.join(", ")}`
            });
        }

        const formNumber = await generateFormNumber(formType);
        let document = null;

        if (req.file) {
            document = {
                formType,
                formNumber,
                pdfFile: req.file.path,
                uploadedAt: new Date(),
                seleMonth,
                approvedBy: [] 
            };
        } else if (pdfData) {
            const pdfFilePath = saveBase64File(pdfData, formNumber);
            if (pdfFilePath) {
                document = {
                    formType,
                    formNumber,
                    pdfFile: pdfFilePath,
                    uploadedAt: new Date(),
                    seleMonth,
                    approvedBy: []  
                };
            } else {
                return res.status(400).json({
                    message: "Invalid base64 PDF data."
                });
            }
        } else {
            return res.status(400).json({
                message: "No file or PDF data provided."
            });
        }

        // This function creates the reporting flow for all roles
        const createDefaultReportingFlow = (userId, userWard, signature, remark, document) => {
            const date = new Date();
        
            return [
                {
                    role: "Lipik",
                    ward: userWard,
                    userId: new mongoose.Types.ObjectId(userId), // Ensure userId is added here
                    remark,
                    signature,
                    date,
                    userWard,
                    documents: document ? [document] : []
                },
                {
                    role: "Junior Engineer",
                    ward: userWard,
                    userId: new mongoose.Types.ObjectId(userId), // Ensure userId is added here
                    date
                },
                {
                    role: "Junior Engineer",
                    ward: "Head Office",
                    userId: new mongoose.Types.ObjectId(userId), // Ensure userId is added here
                    date
                },
                {
                    role: "Accountant",
                    ward: userWard,
                    userId: new mongoose.Types.ObjectId(userId), // Ensure userId is added here
                    date
                },
                {
                    role: "Assistant Municipal Commissioner",
                    ward: userWard,
                    userId: new mongoose.Types.ObjectId(userId), // Ensure userId is added here
                    date
                },
                {
                    role: "Dy.Municipal Commissioner",
                    ward: userWard,
                    userId: new mongoose.Types.ObjectId(userId), // Ensure userId is added here
                    date
                }
            ];
        };

        // The function for creating and adding remarks
        const createRemark = ({ userId, ward, role, remark, signature, document, userWard }) => {
            const remarkObj = {
                userId: new mongoose.Types.ObjectId(userId),
                ward,
                role,
                remark,
                signature,
                userWard,
                date: new Date(),
                documents: []
            };

            if (document && role === "Lipik") {
                remarkObj.documents.push(document);
            }

            if (remark === "Approved" && document) {
                document.approvedBy.push(userId);
            }

            if (document && role !== "Lipik") {
                const lipikRemark = report.reportingRemarks.find(r => r.role === "Lipik");

                if (lipikRemark) {
                    lipikRemark.documents = lipikRemark.documents || [];
                    const docIndex = lipikRemark.documents.findIndex(doc => doc.formType === formType);

                    if (mode === "edit") {
                        if (docIndex !== -1) {
                            const existingDoc = lipikRemark.documents[docIndex];
                            const updatedDoc = {
                                ...existingDoc,
                                ...document,
                                uploadedAt: new Date(),
                                signatures: {
                                    ...(existingDoc.signatures || {}),
                                    [role]: signature
                                },
                                approvedBy: existingDoc.approvedBy || []
                            };

                            if (remark === "Approved" && !updatedDoc.approvedBy.includes(userId)) {
                                updatedDoc.approvedBy.push(userId);
                            }

                            lipikRemark.documents[docIndex] = updatedDoc;
                        } else {
                            lipikRemark.documents.push({
                                ...document,
                                uploadedAt: new Date(),
                                signatures: {
                                    [role]: signature
                                },
                                approvedBy: remark === "Approved" ? [userId] : []  
                            });
                        }
                    } else {
                        const alreadyExists = lipikRemark.documents.some(doc => doc.formType === formType);
                        if (!alreadyExists) {
                            lipikRemark.documents.push({
                                ...document,
                                uploadedAt: new Date(),
                                signatures: {
                                    [role]: signature
                                },
                                approvedBy: remark === "Approved" ? [userId] : []  
                            });
                        }
                    }
                } else {
                    return res.status(400).json({
                        message: "Lipik remark not found. Cannot attach document."
                    });
                }
            }
            return remarkObj;
        };

        // Handle report addition and validation
        if (role === "Junior Engineer" && ward === "Head Office" && wardName) {
            let wardReport = await Report.findOne({ seleMonth, ward: wardName });

            if (!wardReport) {
                return res.status(400).json({
                    message: "The first remark must be from the role 'Lipik'."
                });
            }

            const jeRemark = {
                userId: new mongoose.Types.ObjectId(userId),
                role: "Junior Engineer",
                ward,
                userWard,
                remark,
                signature,
                date: new Date(),
            };

            if (remark === "Approved") {
                jeRemark.approvedBy = new mongoose.Types.ObjectId(userId);
            }

            const jeExists = wardReport.reportingRemarks.some(r =>
                r.userId.toString() === userId &&
                r.role === "Junior Engineer" &&
                r.remark === remark
            );

            if (!jeExists) {
                if (remark === "Approved") {
                    const lipikRemark = wardReport.reportingRemarks.find(r => r.role === "Lipik");
                    if (lipikRemark && lipikRemark.documents?.length > 0) {
                        const docIndex = lipikRemark.documents.findIndex(doc => doc.formType === formType);
                        if (docIndex !== -1) {
                            const doc = lipikRemark.documents[docIndex];
                            if (!doc.approvedBy.includes(userId)) {
                                doc.approvedBy.push(userId);
                            }
                            lipikRemark.documents[docIndex] = doc;
                        }
                    }
                }

                wardReport.reportingRemarks.push(jeRemark);
                await wardReport.save();
            }

            return res.status(201).json({
                message: `Junior Engineer remark added to ward ${wardName} successfully.`,
                report: wardReport
            });
        }

        let report = await Report.findOne({ seleMonth, ward });

        if (!report) {
            report = new Report({
                seleMonth,
                ward,
                monthReport: seleMonth,
            });
        }

        if (report.reportingRemarks.length === 0 && role !== "Lipik") {
            return res.status(400).json({
                message: "The first remark must be from the role 'Lipik'."
            });
        }

        if (report.reportingRemarks.length === 0 && role === "Lipik") {
            // Add all default roles
            const defaultFlow = createDefaultReportingFlow(userId, ward, signature, remark, document);
            report.reportingRemarks = defaultFlow;
        } else {
            const index = report.reportingRemarks.findIndex(r =>
                r.userId.toString() === userId &&
                r.role === role &&
                report.ward === ward
            );

            if (index !== -1) {
                const existing = report.reportingRemarks[index];
                existing.remark = remark;
                existing.signature = signature;
                existing.date = new Date();
                existing.documents = existing.documents || [];

                const docIndex = existing.documents.findIndex(doc => doc.formType === formType);

                if (mode === "edit") {
                    if (docIndex !== -1) {
                        existing.documents[docIndex] = document;
                    } else {
                        existing.documents.push(document);
                    }
                } else {
                    const alreadyExists = existing.documents.some(doc => doc.formType === formType);
                    if (!alreadyExists && document) {
                        existing.documents.push(document);
                    }
                }

                report.reportingRemarks[index] = existing;
            } else {
                const newRemark = createRemark({ userId, role, ward, remark, signature, document, userWard });
                report.reportingRemarks.push(newRemark);
            }
        }

        await report.save();

        res.status(201).json({
            message: "Report added/updated successfully.",
            report
        });

    } catch (error) {
        console.error("🚨 Error adding/updating report:", error);
        res.status(500).json({
            message: "An error occurred while adding the report.",
            error: error.message
        });
    }
};
------------------------------------------------
billDate: {
        type: String,
        required: true,
      },

consumerNumber last billDate cheeck karane paymentStatus==="unpaid" usel tar paid set karane
aani lastReceiptDate > billDate
and lastReceiptAmount eka barobar match hoil netBillAmount or netBillAmountWithDPC or promptPaymentAmount
===================================
BASEURL=http://localhost:5000
API=http://localhost:5000

API=https://lightbillbackend.saavi.co.in
BASEURL=https://lightbillbackend.saavi.co.in
==============================================

const mongoose = require('mongoose');
const Report = require('../models/Report');
const { generateFormNumber, saveBase64File } = require('../utils/fileHelpers');

exports.addRemarkReports = async (req, res) => {
    try {
        const {
            userId,
            remark,
            role,
            signature,
            ward,
            formType,
            pdfData,
            seleMonth,
            wardName,
            mode
        } = req.body;

        let userWard = ward;

        // Validate required fields
        const missingFields = [];
        if (!role) missingFields.push("role");
        if (!remark) missingFields.push("remark");
        if (!formType) missingFields.push("formType");
        if (!seleMonth) missingFields.push("seleMonth");
        if (!ward) missingFields.push("ward");

        if (missingFields.length > 0) {
            return res.status(400).json({
                message: `Missing required fields: ${missingFields.join(", ")}`
            });
        }

        // Handle document creation
        const formNumber = await generateFormNumber(formType);
        let document = null;

        if (req.file) {
            document = {
                formType,
                formNumber,
                pdfFile: req.file.path,
                uploadedAt: new Date(),
                seleMonth,
                approvedBy: [] 
            };
        } else if (pdfData) {
            const pdfFilePath = saveBase64File(pdfData, formNumber);
            if (pdfFilePath) {
                document = {
                    formType,
                    formNumber,
                    pdfFile: pdfFilePath,
                    uploadedAt: new Date(),
                    seleMonth,
                    approvedBy: []  
                };
            } else {
                return res.status(400).json({
                    message: "Invalid base64 PDF data."
                });
            }
        } else {
            return res.status(400).json({
                message: "No file or PDF data provided."
            });
        }

        const createRemark = ({ userId, ward, role, remark, signature, document, userWard }) => {
            const remarkObj = {
                userId: new mongoose.Types.ObjectId(userId),
                ward,
                role,
                remark,
                signature,
                userWard,
                date: new Date(),
                documents: []
            };
            
            if (document && role === "Lipik") {
                remarkObj.documents.push(document);
            }

            if (remark === "Approved" && document) {
                document.approvedBy.push(userId);
            }

            if (document && role !== "Lipik") {
                const lipikRemark = report.reportingRemarks.find(r => r.role === "Lipik");

                if (lipikRemark) {
                    lipikRemark.documents = lipikRemark.documents || [];
                    const docIndex = lipikRemark.documents.findIndex(doc => doc.formType === formType);

                    if (mode === "edit") {
                        if (docIndex !== -1) {
                            const existingDoc = lipikRemark.documents[docIndex];
                            const updatedDoc = {
                                ...existingDoc,
                                ...document,
                                uploadedAt: new Date(),
                                signatures: {
                                    ...(existingDoc.signatures || {}),
                                    [role]: signature
                                },
                                approvedBy: existingDoc.approvedBy || []
                            };

                            if (remark === "Approved" && !updatedDoc.approvedBy.includes(userId)) {
                                updatedDoc.approvedBy.push(userId);
                            }

                            lipikRemark.documents[docIndex] = updatedDoc;
                        } else {
                            lipikRemark.documents.push({
                                ...document,
                                uploadedAt: new Date(),
                                signatures: {
                                    [role]: signature
                                },
                                approvedBy: remark === "Approved" ? [userId] : []  
                            });
                        }
                    } else {
                        // Check if document with the same formType already exists
                        const alreadyExists = lipikRemark.documents.some(doc => doc.formType === formType);
                        if (!alreadyExists) {
                            // If not exists, add as a new document (this is the key change)
                            lipikRemark.documents.push({
                                ...document,
                                uploadedAt: new Date(),
                                signatures: {
                                    [role]: signature
                                },
                                approvedBy: remark === "Approved" ? [userId] : []  
                            });
                        } else {
                            // If exists, update the existing document
                            const docIndex = lipikRemark.documents.findIndex(doc => doc.formType === formType);
                            if (docIndex !== -1) {
                                const existingDoc = lipikRemark.documents[docIndex];
                                existingDoc.uploadedAt = new Date();
                                
                                // Update signatures
                                existingDoc.signatures = existingDoc.signatures || {};
                                existingDoc.signatures[role] = signature;
                                
                                // Update approvedBy
                                if (remark === "Approved" && !existingDoc.approvedBy.includes(userId)) {
                                    existingDoc.approvedBy.push(userId);
                                }
                            }
                        }
                    }
                } else {
                    return res.status(400).json({
                        message: "Lipik remark not found. Cannot attach document."
                    });
                }
            }
            return remarkObj;
        };

        // Special handling for Junior Engineer at Head Office
        if (role === "Junior Engineer" && ward === "Head Office" && wardName) {
            let wardReport = await Report.findOne({ seleMonth, ward: wardName });

            if (!wardReport) {
                return res.status(400).json({
                    message: "Report not found for the specified ward."
                });
            }

            // Check if ward JE has approved - using OR condition for ward/userWard
            const wardJEApproved = wardReport.reportingRemarks.some(r => 
                r.role === "Junior Engineer" && 
                (r.ward === wardName || r.userWard === wardName) && 
                r.remark === "Approved"
            );

            if (!wardJEApproved) {
                return res.status(400).json({
                    message: `Ward ${wardName} Junior Engineer must approve first.`
                });
            }

            const jeRemark = {
                userId: new mongoose.Types.ObjectId(userId),
                role: "Junior Engineer",
                ward: "Head Office",
                userWard: "Head Office",
                remark,
                signature,
                date: new Date(),
            };

            // Check if Head Office JE already exists
            const jeExists = wardReport.reportingRemarks.some(r =>
                r.userId.toString() === userId &&
                r.role === "Junior Engineer" &&
                (r.ward === "Head Office" || r.userWard === "Head Office")
            );

            if (!jeExists) {
                if (remark === "Approved") {
                    const lipikRemark = wardReport.reportingRemarks.find(r => r.role === "Lipik");
                    if (lipikRemark && lipikRemark.documents?.length > 0) {
                        lipikRemark.documents.forEach(doc => {
                            if (!doc.approvedBy.includes(userId)) {
                                doc.approvedBy.push(userId);
                            }
                        });
                    }
                }

                wardReport.reportingRemarks.push(jeRemark);
                await wardReport.save();
            }

            return res.status(201).json({
                message: `Head Office Junior Engineer remark added successfully.`,
                report: wardReport
            });
        }

        // Get or create report for the specified ward
        let report = await Report.findOne({ seleMonth, ward });

        if (!report) {
            report = new Report({
                seleMonth,
                ward,
                monthReport: seleMonth,
            });
        }

        // Validate first remark must be from Lipik
        if (report.reportingRemarks.length === 0 && role !== "Lipik") {
            return res.status(400).json({
                message: "The first remark must be from the role 'Lipik'."
            });
        }

        // Workflow validation based on role
        if (role !== "Lipik") {
            if (role === "Junior Engineer" && ward !== "Head Office") {
                const lipikApproved = report.reportingRemarks.some(r => 
                    r.role === "Lipik" && 
                    r.remark === "Approved"
                );

                if (!lipikApproved) {
                    return res.status(400).json({
                        message: "Lipik must approve first."
                    });
                }
            } else if (role === "Accountant") {
                // FIXED: Check both ward and userWard fields for Junior Engineer approvals
                const wardJEApproved = report.reportingRemarks.some(r => 
                    r.role === "Junior Engineer" && 
                    (r.ward === ward || r.userWard === ward) &&
                    r.remark === "Approved"
                );

                const headOfficeJEApproved = report.reportingRemarks.some(r => 
                    r.role === "Junior Engineer" && 
                    (r.ward === "Head Office" || r.userWard === "Head Office") &&
                    r.remark === "Approved"
                );

                if (!wardJEApproved || !headOfficeJEApproved) {
                    return res.status(400).json({
                        message: "Both Ward Junior Engineer and Head Office Junior Engineer must approve first."
                    });
                }
            } else if (role === "Assistant Municipal Commissioner") {
                const accountantApproved = report.reportingRemarks.some(r => 
                    r.role === "Accountant" && 
                    r.remark === "Approved"
                );

                if (!accountantApproved) {
                    return res.status(400).json({
                        message: "Accountant must approve first."
                    });
                }
            } else if (role === "Dy.Municipal Commissioner") {
                const amcApproved = report.reportingRemarks.some(r => 
                    r.role === "Assistant Municipal Commissioner" && 
                    r.remark === "Approved"
                );

                if (!amcApproved) {
                    return res.status(400).json({
                        message: "Assistant Municipal Commissioner must approve first."
                    });
                }
            }
        }

        // Update existing remark or create a new one
        const index = report.reportingRemarks.findIndex(r =>
            r.userId.toString() === userId &&
            r.role === role &&
            (r.ward === ward || r.userWard === ward)
        );

        if (index !== -1) {
            const existing = report.reportingRemarks[index];
            existing.remark = remark;
            existing.signature = signature;
            existing.date = new Date();
            
            // Handle documents for Lipik role
            if (role === "Lipik") {
                existing.documents = existing.documents || [];
                const docIndex = existing.documents.findIndex(doc => doc.formType === formType);
                
                if (docIndex !== -1) {
                    // Update existing document of the same type
                    const existingDoc = existing.documents[docIndex];
                    existingDoc.uploadedAt = new Date();
                    existingDoc.pdfFile = document.pdfFile;
                    
                    // Reset approvals if document is updated
                    if (mode === "edit") {
                        existingDoc.approvedBy = [userId];
                    }
                } else {
                    // Add new document with different formType
                    existing.documents.push({
                        ...document,
                        uploadedAt: new Date(),
                        approvedBy: [userId]
                    });
                }
            }

            if (remark === "Approved") {
                const lipikRemark = report.reportingRemarks.find(r => r.role === "Lipik");
                if (lipikRemark && lipikRemark.documents?.length > 0) {
                    lipikRemark.documents.forEach(doc => {
                        if (!doc.approvedBy.includes(userId)) {
                            doc.approvedBy.push(userId);
                        }
                    });
                }
            }

            report.reportingRemarks[index] = existing;
        } else {
            const newRemark = createRemark({ userId, role, ward, remark, signature, document, userWard });
            report.reportingRemarks.push(newRemark);
        }

        await report.save();

        res.status(201).json({
            message: "Report added/updated successfully.",
            report
        });

    } catch (error) {
        console.error("🚨 Error adding/updating report:", error);
        res.status(500).json({
            message: "An error occurred while adding the report.",
            error: error.message
        });
    }
};

exports.getReports = async (req, res) => {
    try {
        const reports = await Report.find().sort({ updatedAt: -1 });
        res.status(200).json(reports);
    } catch (error) {
        console.error("Error fetching reports:", error);
        res.status(500).json({
            message: "An error occurred while fetching reports.",
            error: error.message
        });
    }
};

exports.searchReport = async (req, res) => {
    try {
        const { seleMonth, ward } = req.body;
        const query = {};
        
        if (seleMonth) query.seleMonth = seleMonth;
        if (ward) query.ward = ward;
        
        const reports = await Report.find(query).sort({ updatedAt: -1 });
        res.status(200).json(reports);
    } catch (error) {
        console.error("Error searching reports:", error);
        res.status(500).json({
            message: "An error occurred while searching for reports.",
            error: error.message
        });
    }
};

exports.deleteMonthReport = async (req, res) => {
    try {
        const { month } = req.params;
        
        const result = await Report.deleteMany({ seleMonth: month });
        
        if (result.deletedCount > 0) {
            res.status(200).json({
                message: `Successfully deleted ${result.deletedCount} reports for month ${month}.`
            });
        } else {
            res.status(404).json({
                message: `No reports found for month ${month}.`
            });
        }
    } catch (error) {
        console.error("Error deleting reports:", error);
        res.status(500).json({
            message: "An error occurred while deleting reports.",
            error: error.message
        });
    }
};

-----------------------------------------------

const mongoose = require('mongoose');
const Report = require('../models/Report');
const { generateFormNumber, saveBase64File } = require('../utils/fileHelpers');

exports.addRemarkReports = async (req, res) => {
    try {
        const {
            userId,
            remark,
            role,
            signature,
            ward,
            formType,
            pdfData,
            seleMonth,
            wardName,
            mode
        } = req.body;

        let userWard = ward;

        // Validate required fields
        const missingFields = [];
        if (!role) missingFields.push("role");
        if (!remark) missingFields.push("remark");
        if (!formType) missingFields.push("formType");
        if (!seleMonth) missingFields.push("seleMonth");
        if (!ward) missingFields.push("ward");

        if (missingFields.length > 0) {
            return res.status(400).json({
                message: `Missing required fields: ${missingFields.join(", ")}`
            });
        }

        // Handle document creation
        const formNumber = await generateFormNumber(formType);
        let document = null;

        if (req.file) {
            document = {
                formType,
                formNumber,
                pdfFile: req.file.path,
                uploadedAt: new Date(),
                seleMonth,
                approvedBy: [] 
            };
        } else if (pdfData) {
            const pdfFilePath = saveBase64File(pdfData, formNumber);
            if (pdfFilePath) {
                document = {
                    formType,
                    formNumber,
                    pdfFile: pdfFilePath,
                    uploadedAt: new Date(),
                    seleMonth,
                    approvedBy: []  
                };
            } else {
                return res.status(400).json({
                    message: "Invalid base64 PDF data."
                });
            }
        } else {
            return res.status(400).json({
                message: "No file or PDF data provided."
            });
        }

        const createRemark = ({ userId, ward, role, remark, signature, document, userWard }) => {
            const remarkObj = {
                userId: new mongoose.Types.ObjectId(userId),
                ward,
                role,
                remark,
                signature,
                userWard,
                date: new Date(),
                documents: []
            };
            
            if (document && role === "Lipik") {
                remarkObj.documents.push(document);
            }

            if (remark === "Approved" && document) {
                document.approvedBy.push(userId);
            }

            if (document && role !== "Lipik") {
                const lipikRemark = report.reportingRemarks.find(r => r.role === "Lipik");

                if (lipikRemark) {
                    lipikRemark.documents = lipikRemark.documents || [];
                    const docIndex = lipikRemark.documents.findIndex(doc => doc.formType === formType);

                    if (mode === "edit") {
                        if (docIndex !== -1) {
                            const existingDoc = lipikRemark.documents[docIndex];
                            const updatedDoc = {
                                ...existingDoc,
                                ...document,
                                uploadedAt: new Date(),
                                signatures: {
                                    ...(existingDoc.signatures || {}),
                                    [role]: signature
                                },
                                approvedBy: existingDoc.approvedBy || []
                            };

                            if (remark === "Approved" && !updatedDoc.approvedBy.includes(userId)) {
                                updatedDoc.approvedBy.push(userId);
                            }

                            lipikRemark.documents[docIndex] = updatedDoc;
                        } else {
                            lipikRemark.documents.push({
                                ...document,
                                uploadedAt: new Date(),
                                signatures: {
                                    [role]: signature
                                },
                                approvedBy: remark === "Approved" ? [userId] : []  
                            });
                        }
                    } else {
                        // Check if document with the same formType already exists
                        const alreadyExists = lipikRemark.documents.some(doc => doc.formType === formType);
                        if (!alreadyExists) {
                            // If not exists, add as a new document (this is the key change)
                            lipikRemark.documents.push({
                                ...document,
                                uploadedAt: new Date(),
                                signatures: {
                                    [role]: signature
                                },
                                approvedBy: remark === "Approved" ? [userId] : []  
                            });
                        } else {
                            // If exists, update the existing document
                            const docIndex = lipikRemark.documents.findIndex(doc => doc.formType === formType);
                            if (docIndex !== -1) {
                                const existingDoc = lipikRemark.documents[docIndex];
                                existingDoc.uploadedAt = new Date();
                                
                                // Update signatures
                                existingDoc.signatures = existingDoc.signatures || {};
                                existingDoc.signatures[role] = signature;
                                
                                // Update approvedBy
                                if (remark === "Approved" && !existingDoc.approvedBy.includes(userId)) {
                                    existingDoc.approvedBy.push(userId);
                                }
                            }
                        }
                    }
                } else {
                    return res.status(400).json({
                        message: "Lipik remark not found. Cannot attach document."
                    });
                }
            }
            return remarkObj;
        };

        // Special handling for Junior Engineer at Head Office
        if (role === "Junior Engineer" && ward === "Head Office" && wardName) {
            let wardReport = await Report.findOne({ seleMonth, ward: wardName });

            if (!wardReport) {
                return res.status(400).json({
                    message: "Report not found for the specified ward."
                });
            }

            // Check if ward JE has approved - using OR condition for ward/userWard
            const wardJEApproved = wardReport.reportingRemarks.some(r => 
                r.role === "Junior Engineer" && 
                (r.ward === wardName || r.userWard === wardName) && 
                r.remark === "Approved"
            );

            if (!wardJEApproved) {
                return res.status(400).json({
                    message: `Ward ${wardName} Junior Engineer must approve first.`
                });
            }

            const jeRemark = {
                userId: new mongoose.Types.ObjectId(userId),
                role: "Junior Engineer",
                ward: "Head Office",
                userWard: "Head Office",
                remark,
                signature,
                date: new Date(),
            };

            // Check if Head Office JE already exists
            const jeExists = wardReport.reportingRemarks.some(r =>
                r.userId.toString() === userId &&
                r.role === "Junior Engineer" &&
                (r.ward === "Head Office" || r.userWard === "Head Office")
            );

            if (!jeExists) {
                if (remark === "Approved") {
                    const lipikRemark = wardReport.reportingRemarks.find(r => r.role === "Lipik");
                    if (lipikRemark && lipikRemark.documents?.length > 0) {
                        lipikRemark.documents.forEach(doc => {
                            if (!doc.approvedBy.includes(userId)) {
                                doc.approvedBy.push(userId);
                            }
                        });
                    }
                }

                wardReport.reportingRemarks.push(jeRemark);
                await wardReport.save();
            }

            return res.status(201).json({
                message: `Head Office Junior Engineer remark added successfully.`,
                report: wardReport
            });
        }

        // Get or create report for the specified ward
        let report = await Report.findOne({ seleMonth, ward });

        if (!report) {
            report = new Report({
                seleMonth,
                ward,
                monthReport: seleMonth,
            });
        }

        // Validate first remark must be from Lipik
        if (report.reportingRemarks.length === 0 && role !== "Lipik") {
            return res.status(400).json({
                message: "The first remark must be from the role 'Lipik'."
            });
        }

        // Workflow validation based on role
        if (role !== "Lipik") {
            if (role === "Junior Engineer" && ward !== "Head Office") {
                const lipikApproved = report.reportingRemarks.some(r => 
                    r.role === "Lipik" && 
                    r.remark === "Approved"
                );

                if (!lipikApproved) {
                    return res.status(400).json({
                        message: "Lipik must approve first."
                    });
                }
            } else if (role === "Accountant") {
                // FIXED: Check both ward and userWard fields for Junior Engineer approvals
                const wardJEApproved = report.reportingRemarks.some(r => 
                    r.role === "Junior Engineer" && 
                    (r.ward === ward || r.userWard === ward) &&
                    r.remark === "Approved"
                );

                const headOfficeJEApproved = report.reportingRemarks.some(r => 
                    r.role === "Junior Engineer" && 
                    (r.ward === "Head Office" || r.userWard === "Head Office") &&
                    r.remark === "Approved"
                );

                if (!wardJEApproved || !headOfficeJEApproved) {
                    return res.status(400).json({
                        message: "Both Ward Junior Engineer and Head Office Junior Engineer must approve first."
                    });
                }
            } else if (role === "Assistant Municipal Commissioner") {
                const accountantApproved = report.reportingRemarks.some(r => 
                    r.role === "Accountant" && 
                    r.remark === "Approved"
                );

                if (!accountantApproved) {
                    return res.status(400).json({
                        message: "Accountant must approve first."
                    });
                }
            } else if (role === "Dy.Municipal Commissioner") {
                const amcApproved = report.reportingRemarks.some(r => 
                    r.role === "Assistant Municipal Commissioner" && 
                    r.remark === "Approved"
                );

                if (!amcApproved) {
                    return res.status(400).json({
                        message: "Assistant Municipal Commissioner must approve first."
                    });
                }
            }
        }

        // Update existing remark or create a new one
        const index = report.reportingRemarks.findIndex(r =>
            r.userId.toString() === userId &&
            r.role === role &&
            (r.ward === ward || r.userWard === ward)
        );

        if (index !== -1) {
            const existing = report.reportingRemarks[index];
            existing.remark = remark;
            existing.signature = signature;
            existing.date = new Date();
            
            // Handle documents for Lipik role
            if (role === "Lipik") {
                existing.documents = existing.documents || [];
                const docIndex = existing.documents.findIndex(doc => doc.formType === formType);
                
                if (docIndex !== -1) {
                    // Update existing document of the same type
                    const existingDoc = existing.documents[docIndex];
                    existingDoc.uploadedAt = new Date();
                    existingDoc.pdfFile = document.pdfFile;
                    
                    // Reset approvals if document is updated
                    if (mode === "edit") {
                        existingDoc.approvedBy = [userId];
                    }
                } else {
                    // Add new document with different formType
                    existing.documents.push({
                        ...document,
                        uploadedAt: new Date(),
                        approvedBy: [userId]
                    });
                }
            }

            if (remark === "Approved") {
                const lipikRemark = report.reportingRemarks.find(r => r.role === "Lipik");
                if (lipikRemark && lipikRemark.documents?.length > 0) {
                    lipikRemark.documents.forEach(doc => {
                        if (!doc.approvedBy.includes(userId)) {
                            doc.approvedBy.push(userId);
                        }
                    });
                }
            }

            report.reportingRemarks[index] = existing;
        } else {
            const newRemark = createRemark({ userId, role, ward, remark, signature, document, userWard });
            report.reportingRemarks.push(newRemark);
        }

        await report.save();

        res.status(201).json({
            message: "Report added/updated successfully.",
            report
        });

    } catch (error) {
        console.error("🚨 Error adding/updating report:", error);
        res.status(500).json({
            message: "An error occurred while adding the report.",
            error: error.message
        });
    }
};

exports.getReports = async (req, res) => {
    try {
        const reports = await Report.find().sort({ updatedAt: -1 });
        res.status(200).json(reports);
    } catch (error) {
        console.error("Error fetching reports:", error);
        res.status(500).json({
            message: "An error occurred while fetching reports.",
            error: error.message
        });
    }
};

exports.searchReport = async (req, res) => {
    try {
        const { seleMonth, ward } = req.body;
        const query = {};
        
        if (seleMonth) query.seleMonth = seleMonth;
        if (ward) query.ward = ward;
        
        const reports = await Report.find(query).sort({ updatedAt: -1 });
        res.status(200).json(reports);
    } catch (error) {
        console.error("Error searching reports:", error);
        res.status(500).json({
            message: "An error occurred while searching for reports.",
            error: error.message
        });
    }
};

exports.deleteMonthReport = async (req, res) => {
    try {
        const { month } = req.params;
        
        const result = await Report.deleteMany({ seleMonth: month });
        
        if (result.deletedCount > 0) {
            res.status(200).json({
                message: `Successfully deleted ${result.deletedCount} reports for month ${month}.`
            });
        } else {
            res.status(404).json({
                message: `No reports found for month ${month}.`
            });
        }
    } catch (error) {
        console.error("Error deleting reports:", error);
        res.status(500).json({
            message: "An error occurred while deleting reports.",
            error: error.message
        });
    }
};
---------------------------------------------
const mongoose = require('mongoose');
const Report = require('../models/Report');
const { generateFormNumber, saveBase64File } = require('../utils/fileHelpers');

exports.addRemarkReports = async (req, res) => {
    try {
        const {
            userId,
            remark,
            role,
            signature,
            ward,
            formType,
            pdfData,
            seleMonth,
            wardName,
            mode
        } = req.body;

        let userWard = ward;

        // Validate required fields
        const missingFields = [];
        if (!role) missingFields.push("role");
        if (!remark) missingFields.push("remark");
        if (!formType) missingFields.push("formType");
        if (!seleMonth) missingFields.push("seleMonth");
        if (!ward) missingFields.push("ward");

        if (missingFields.length > 0) {
            return res.status(400).json({
                message: `Missing required fields: ${missingFields.join(", ")}`
            });
        }

        // Handle document creation
        const formNumber = await generateFormNumber(formType);
        let document = null;

        if (req.file) {
            document = {
                formType,
                formNumber,
                pdfFile: req.file.path,
                uploadedAt: new Date(),
                seleMonth,
                approvedBy: [] 
            };
        } else if (pdfData) {
            const pdfFilePath = saveBase64File(pdfData, formNumber);
            if (pdfFilePath) {
                document = {
                    formType,
                    formNumber,
                    pdfFile: pdfFilePath,
                    uploadedAt: new Date(),
                    seleMonth,
                    approvedBy: []  
                };
            } else {
                return res.status(400).json({
                    message: "Invalid base64 PDF data."
                });
            }
        } else {
            return res.status(400).json({
                message: "No file or PDF data provided."
            });
        }

        const createRemark = ({ userId, ward, role, remark, signature, document, userWard }) => {
            const remarkObj = {
                userId: new mongoose.Types.ObjectId(userId),
                ward,
                role,
                remark,
                signature,
                userWard,
                date: new Date(),
                documents: []
            };
            
            if (document && role === "Lipik") {
                remarkObj.documents.push(document);
            }

            if (remark === "Approved" && document) {
                document.approvedBy.push(userId);
            }

            if (document && role !== "Lipik") {
                const lipikRemark = report.reportingRemarks.find(r => r.role === "Lipik");

                if (lipikRemark) {
                    lipikRemark.documents = lipikRemark.documents || [];
                    const docIndex = lipikRemark.documents.findIndex(doc => doc.formType === formType);

                    if (mode === "edit") {
                        if (docIndex !== -1) {
                            const existingDoc = lipikRemark.documents[docIndex];
                            const updatedDoc = {
                                ...existingDoc,
                                ...document,
                                uploadedAt: new Date(),
                                signatures: {
                                    ...(existingDoc.signatures || {}),
                                    [role]: signature
                                },
                                approvedBy: existingDoc.approvedBy || []
                            };

                            if (remark === "Approved" && !updatedDoc.approvedBy.includes(userId)) {
                                updatedDoc.approvedBy.push(userId);
                            }

                            lipikRemark.documents[docIndex] = updatedDoc;
                        } else {
                            lipikRemark.documents.push({
                                ...document,
                                uploadedAt: new Date(),
                                signatures: {
                                    [role]: signature
                                },
                                approvedBy: remark === "Approved" ? [userId] : []  
                            });
                        }
                    } else {
                        const alreadyExists = lipikRemark.documents.some(doc => doc.formType === formType);
                        if (!alreadyExists) {
                            lipikRemark.documents.push({
                                ...document,
                                uploadedAt: new Date(),
                                signatures: {
                                    [role]: signature
                                },
                                approvedBy: remark === "Approved" ? [userId] : []  
                            });
                        } else {
                            const docIndex = lipikRemark.documents.findIndex(doc => doc.formType === formType);
                            if (docIndex !== -1) {
                                const existingDoc = lipikRemark.documents[docIndex];
                                if (remark === "Approved" && !existingDoc.approvedBy.includes(userId)) {
                                    existingDoc.approvedBy.push(userId);
                                }
                            }
                        }
                    }
                } else {
                    return res.status(400).json({
                        message: "Lipik remark not found. Cannot attach document."
                    });
                }
            }
            return remarkObj;
        };

        // Special handling for Junior Engineer at Head Office
        if (role === "Junior Engineer" && ward === "Head Office" && wardName) {
            let wardReport = await Report.findOne({ seleMonth, ward: wardName });

            if (!wardReport) {
                return res.status(400).json({
                    message: "Report not found for the specified ward."
                });
            }

            const wardJEApproved = wardReport.reportingRemarks.some(r => 
                r.role === "Junior Engineer" && 
                (r.ward === wardName || r.userWard === wardName) && 
                r.remark === "Approved"
            );

            if (!wardJEApproved) {
                return res.status(400).json({
                    message: `Ward ${wardName} Junior Engineer must approve first.`
                });
            }

            const jeRemark = {
                userId: new mongoose.Types.ObjectId(userId),
                role: "Junior Engineer",
                ward: "Head Office",
                userWard: "Head Office",
                remark,
                signature,
                date: new Date(),
            };

            const jeExists = wardReport.reportingRemarks.some(r =>
                r.userId.toString() === userId &&
                r.role === "Junior Engineer" &&
                (r.ward === "Head Office" || r.userWard === "Head Office")
            );

            if (!jeExists) {
                if (remark === "Approved") {
                    const lipikRemark = wardReport.reportingRemarks.find(r => r.role === "Lipik");
                    if (lipikRemark && lipikRemark.documents?.length > 0) {
                        lipikRemark.documents.forEach(doc => {
                            if (!doc.approvedBy.includes(userId)) {
                                doc.approvedBy.push(userId);
                            }
                        });
                    }
                }

                wardReport.reportingRemarks.push(jeRemark);
                await wardReport.save();
            }

            // Update the original ward's report to include Head Office JE approval
            let originalWardReport = await Report.findOne({ seleMonth, ward: wardName });
            if (originalWardReport) {
                const lipikRemark = originalWardReport.reportingRemarks.find(r => r.role === "Lipik");
                if (lipikRemark && lipikRemark.documents?.length > 0) {
                    lipikRemark.documents.forEach(doc => {
                        if (remark === "Approved" && !doc.approvedBy.includes(userId)) {
                            doc.approvedBy.push(userId);
                        }
                    });
                }
                await originalWardReport.save();
            }

            return res.status(201).json({
                message: `Head Office Junior Engineer remark added successfully.`,
                report: wardReport
            });
        }

        // Get or create report for the specified ward
        let report = await Report.findOne({ seleMonth, ward });

        if (!report) {
            report = new Report({
                seleMonth,
                ward,
                monthReport: seleMonth,
            });
        }

        // Validate first remark must be from Lipik
        if (report.reportingRemarks.length === 0 && role !== "Lipik") {
            return res.status(400).json({
                message: "The first remark must be from the role 'Lipik'."
            });
        }

        // Workflow validation based on role
        if (role !== "Lipik") {
            if (role === "Junior Engineer" && ward !== "Head Office") {
                const lipikApproved = report.reportingRemarks.some(r => 
                    r.role === "Lipik" && 
                    r.remark === "Approved"
                );

                if (!lipikApproved) {
                    return res.status(400).json({
                        message: "Lipik must approve first."
                    });
                }
            } else if (role === "Accountant") {
                const wardJEApproved = report.reportingRemarks.some(r => 
                    r.role === "Junior Engineer" && 
                    (r.ward === ward || r.userWard === ward) &&
                    r.remark === "Approved"
                );

                const headOfficeJEApproved = report.reportingRemarks.some(r => 
                    r.role === "Junior Engineer" && 
                    (r.ward === "Head Office" || r.userWard === "Head Office") &&
                    r.remark === "Approved"
                );

                if (!wardJEApproved || !headOfficeJEApproved) {
                    return res.status(400).json({
                        message: "Both Ward Junior Engineer and Head Office Junior Engineer must approve first."
                    });
                }
            } else if (role === "Assistant Municipal Commissioner") {
                const accountantApproved = report.reportingRemarks.some(r => 
                    r.role === "Accountant" && 
                    r.remark === "Approved"
                );

                if (!accountantApproved) {
                    return res.status(400).json({
                        message: "Accountant must approve first."
                    });
                }
            } else if (role === "Dy.Municipal Commissioner") {
                const amcApproved = report.reportingRemarks.some(r => 
                    r.role === "Assistant Municipal Commissioner" && 
                    r.remark === "Approved"
                );

                if (!amcApproved) {
                    return res.status(400).json({
                        message: "Assistant Municipal Commissioner must approve first."
                    });
                }
            }
        }

        // Update existing remark or create a new one
        const index = report.reportingRemarks.findIndex(r =>
            r.userId.toString() === userId &&
            r.role === role &&
            (r.ward === ward || r.userWard === ward)
        );

        if (index !== -1) {
            const existing = report.reportingRemarks[index];
            existing.remark = remark;
            existing.signature = signature;
            existing.date = new Date();
            
            if (remark === "Approved") {
                const lipikRemark = report.reportingRemarks.find(r => r.role === "Lipik");
                if (lipikRemark && lipikRemark.documents?.length > 0) {
                    lipikRemark.documents.forEach(doc => {
                        if (!doc.approvedBy.includes(userId)) {
                            doc.approvedBy.push(userId);
                        }
                    });
                }
            }

            report.reportingRemarks[index] = existing;
        } else {
            const newRemark = createRemark({ userId, role, ward, remark, signature, document, userWard });
            report.reportingRemarks.push(newRemark);
        }

        await report.save();

        res.status(201).json({
            message: "Report added/updated successfully.",
            report
        });

    } catch (error) {
        console.error("🚨 Error adding/updating report:", error);
        res.status(500).json({
            message: "An error occurred while adding the report.",
            error: error.message
        });
    }
};
-------------------------------------------------------------------
const mongoose = require('mongoose');
const Report = require('../models/Report');
const { generateFormNumber, saveBase64File } = require('../utils/fileHelpers');

exports.addRemarkReports = async (req, res) => {
    try {
        const {
            userId,
            remark,
            role,
            signature,
            ward,
            formType,
            pdfData,
            seleMonth,
            wardName,
            mode
        } = req.body;

        let userWard = ward;

        // Validate required fields
        const missingFields = [];
        if (!role) missingFields.push("role");
        if (!remark) missingFields.push("remark");
        if (!formType) missingFields.push("formType");
        if (!seleMonth) missingFields.push("seleMonth");
        if (!ward) missingFields.push("ward");

        if (missingFields.length > 0) {
            return res.status(400).json({
                message: `Missing required fields: ${missingFields.join(", ")}`
            });
        }

        // Handle document creation
        const formNumber = await generateFormNumber(formType);
        let document = null;

        if (req.file) {
            document = {
                formType,
                formNumber,
                pdfFile: req.file.path,
                uploadedAt: new Date(),
                seleMonth,
                approvedBy: [] 
            };
        } else if (pdfData) {
            const pdfFilePath = saveBase64File(pdfData, formNumber);
            if (pdfFilePath) {
                document = {
                    formType,
                    formNumber,
                    pdfFile: pdfFilePath,
                    uploadedAt: new Date(),
                    seleMonth,
                    approvedBy: []  
                };
            } else {
                return res.status(400).json({
                    message: "Invalid base64 PDF data."
                });
            }
        } else {
            return res.status(400).json({
                message: "No file or PDF data provided."
            });
        }

        const createRemark = ({ userId, ward, role, remark, signature, document, userWard }) => {
            const remarkObj = {
                userId: new mongoose.Types.ObjectId(userId),
                ward,
                role,
                remark,
                signature,
                userWard,
                date: new Date(),
                documents: []
            };
            
            if (document && role === "Lipik") {
                const lipikRemark = report.reportingRemarks.find(r => r.role === "Lipik");
                if (lipikRemark) {
                    // Check if document with this formType already exists
                    const existingDocIndex = lipikRemark.documents.findIndex(doc => doc.formType === document.formType);
                    if (existingDocIndex === -1) {
                        // If no document with this formType exists, add new one
                        remarkObj.documents.push(document);
                    } else {
                        // If document exists, update it
                        lipikRemark.documents[existingDocIndex] = {
                            ...document,
                            approvedBy: [userId]
                        };
                    }
                } else {
                    remarkObj.documents.push(document);
                }
            }

            if (remark === "Approved" && document) {
                document.approvedBy.push(userId);
            }

            if (document && role !== "Lipik") {
                const lipikRemark = report.reportingRemarks.find(r => r.role === "Lipik");

                if (lipikRemark) {
                    lipikRemark.documents = lipikRemark.documents || [];
                    const docIndex = lipikRemark.documents.findIndex(doc => doc.formType === formType);

                    if (mode === "edit") {
                        if (docIndex !== -1) {
                            const existingDoc = lipikRemark.documents[docIndex];
                            const updatedDoc = {
                                ...existingDoc,
                                ...document,
                                uploadedAt: new Date(),
                                signatures: {
                                    ...(existingDoc.signatures || {}),
                                    [role]: signature
                                },
                                approvedBy: existingDoc.approvedBy || []
                            };

                            if (remark === "Approved" && !updatedDoc.approvedBy.includes(userId)) {
                                updatedDoc.approvedBy.push(userId);
                            }

                            lipikRemark.documents[docIndex] = updatedDoc;
                        } else {
                            lipikRemark.documents.push({
                                ...document,
                                uploadedAt: new Date(),
                                signatures: {
                                    [role]: signature
                                },
                                approvedBy: remark === "Approved" ? [userId] : []  
                            });
                        }
                    } else {
                        const existingDoc = lipikRemark.documents.find(doc => doc.formType === formType);
                        if (!existingDoc) {
                            // Add new document if formType doesn't exist
                            lipikRemark.documents.push({
                                ...document,
                                uploadedAt: new Date(),
                                signatures: {
                                    [role]: signature
                                },
                                approvedBy: remark === "Approved" ? [userId] : []  
                            });
                        } else {
                            // Update existing document's approval status
                            if (remark === "Approved" && !existingDoc.approvedBy.includes(userId)) {
                                existingDoc.approvedBy.push(userId);
                            }
                            existingDoc.signatures = {
                                ...(existingDoc.signatures || {}),
                                [role]: signature
                            };
                        }
                    }
                } else {
                    return res.status(400).json({
                        message: "Lipik remark not found. Cannot attach document."
                    });
                }
            }
            return remarkObj;
        };

        // Special handling for Junior Engineer at Head Office
        if (role === "Junior Engineer" && ward === "Head Office" && wardName) {
            let wardReport = await Report.findOne({ seleMonth, ward: wardName });

            if (!wardReport) {
                return res.status(400).json({
                    message: "Report not found for the specified ward."
                });
            }

            const wardJEApproved = wardReport.reportingRemarks.some(r => 
                r.role === "Junior Engineer" && 
                (r.ward === wardName || r.userWard === wardName) && 
                r.remark === "Approved"
            );

            if (!wardJEApproved) {
                return res.status(400).json({
                    message: `Ward ${wardName} Junior Engineer must approve first.`
                });
            }

            const jeRemark = {
                userId: new mongoose.Types.ObjectId(userId),
                role: "Junior Engineer",
                ward: "Head Office",
                userWard: "Head Office",
                remark,
                signature,
                date: new Date(),
            };

            const jeExists = wardReport.reportingRemarks.some(r =>
                r.userId.toString() === userId &&
                r.role === "Junior Engineer" &&
                (r.ward === "Head Office" || r.userWard === "Head Office")
            );

            if (!jeExists) {
                if (remark === "Approved") {
                    const lipikRemark = wardReport.reportingRemarks.find(r => r.role === "Lipik");
                    if (lipikRemark && lipikRemark.documents?.length > 0) {
                        lipikRemark.documents.forEach(doc => {
                            if (!doc.approvedBy.includes(userId)) {
                                doc.approvedBy.push(userId);
                            }
                        });
                    }
                }

                wardReport.reportingRemarks.push(jeRemark);
                await wardReport.save();
            }

            // Update the original ward's report to include Head Office JE approval
            let originalWardReport = await Report.findOne({ seleMonth, ward: wardName });
            if (originalWardReport) {
                const lipikRemark = originalWardReport.reportingRemarks.find(r => r.role === "Lipik");
                if (lipikRemark && lipikRemark.documents?.length > 0) {
                    lipikRemark.documents.forEach(doc => {
                        if (remark === "Approved" && !doc.approvedBy.includes(userId)) {
                            doc.approvedBy.push(userId);
                        }
                    });
                }
                await originalWardReport.save();
            }

            return res.status(201).json({
                message: `Head Office Junior Engineer remark added successfully.`,
                report: wardReport
            });
        }

        // Get or create report for the specified ward
        let report = await Report.findOne({ seleMonth, ward });

        if (!report) {
            report = new Report({
                seleMonth,
                ward,
                monthReport: seleMonth,
            });
        }

        // Validate first remark must be from Lipik
        if (report.reportingRemarks.length === 0 && role !== "Lipik") {
            return res.status(400).json({
                message: "The first remark must be from the role 'Lipik'."
            });
        }

        // Workflow validation based on role
        if (role !== "Lipik") {
            if (role === "Junior Engineer" && ward !== "Head Office") {
                const lipikApproved = report.reportingRemarks.some(r => 
                    r.role === "Lipik" && 
                    r.remark === "Approved"
                );

                if (!lipikApproved) {
                    return res.status(400).json({
                        message: "Lipik must approve first."
                    });
                }
            } else if (role === "Accountant") {
                const wardJEApproved = report.reportingRemarks.some(r => 
                    r.role === "Junior Engineer" && 
                    (r.ward === ward || r.userWard === ward) &&
                    r.remark === "Approved"
                );

                const headOfficeJEApproved = report.reportingRemarks.some(r => 
                    r.role === "Junior Engineer" && 
                    (r.ward === "Head Office" || r.userWard === "Head Office") &&
                    r.remark === "Approved"
                );

                if (!wardJEApproved || !headOfficeJEApproved) {
                    return res.status(400).json({
                        message: "Both Ward Junior Engineer and Head Office Junior Engineer must approve first."
                    });
                }
            } else if (role === "Assistant Municipal Commissioner") {
                const accountantApproved = report.reportingRemarks.some(r => 
                    r.role === "Accountant" && 
                    r.remark === "Approved"
                );

                if (!accountantApproved) {
                    return res.status(400).json({
                        message: "Accountant must approve first."
                    });
                }
            } else if (role === "Dy.Municipal Commissioner") {
                const amcApproved = report.reportingRemarks.some(r => 
                    r.role === "Assistant Municipal Commissioner" && 
                    r.remark === "Approved"
                );

                if (!amcApproved) {
                    return res.status(400).json({
                        message: "Assistant Municipal Commissioner must approve first."
                    });
                }
            }
        }

        // Update existing remark or create a new one
        const index = report.reportingRemarks.findIndex(r =>
            r.userId.toString() === userId &&
            r.role === role &&
            (r.ward === ward || r.userWard === ward)
        );

        if (index !== -1) {
            const existing = report.reportingRemarks[index];
            existing.remark = remark;
            existing.signature = signature;
            existing.date = new Date();
            
            if (remark === "Approved") {
                const lipikRemark = report.reportingRemarks.find(r => r.role === "Lipik");
                if (lipikRemark && lipikRemark.documents?.length > 0) {
                    lipikRemark.documents.forEach(doc => {
                        if (!doc.approvedBy.includes(userId)) {
                            doc.approvedBy.push(userId);
                        }
                    });
                }
            }

            report.reportingRemarks[index] = existing;
        } else {
            const newRemark = createRemark({ userId, role, ward, remark, signature, document, userWard });
            report.reportingRemarks.push(newRemark);
        }

        await report.save();

        res.status(201).json({
            message: "Report added/updated successfully.",
            report
        });

    } catch (error) {
        console.error("🚨 Error adding/updating report:", error);
        res.status(500).json({
            message: "An error occurred while adding the report.",
            error: error.message
        });
    }
};
===================================
23 May 2025
-----
// Enhanced form approval workflow system
const mongoose = require('mongoose');

// Required form types that must be approved at each level
const REQUIRED_FORM_TYPES = ['wardbilllist', 'form22', 'karyalayintipani'];

// Function to check if all required forms are approved by a specific role
const areAllFormsApprovedByRole = (report, role, ward) => {
  // Find the remark for the specified role
  const roleRemark = report.reportingRemarks.find(r => 
    r.role === role && 
    (r.ward === ward || r.userWard === ward) &&
    r.remark === "Approved"
  );

  if (!roleRemark) return false;

  // For Lipik, check if all form types exist in their documents array
  if (role === "Lipik") {
    // Get all form types that the Lipik has in their documents
    const approvedFormTypes = roleRemark.documents.map(doc => doc.formType);
    
    // Check if all required form types are approved
    return REQUIRED_FORM_TYPES.every(formType => approvedFormTypes.includes(formType));
  } 
  
  // For other roles, we need to check if they've approved all the Lipik documents
  const lipikRemark = report.reportingRemarks.find(r => r.role === "Lipik");
  
  if (!lipikRemark || !lipikRemark.documents || lipikRemark.documents.length === 0) {
    return false;
  }

  // Check if all required form types exist and are approved by this user
  return REQUIRED_FORM_TYPES.every(formType => {
    const doc = lipikRemark.documents.find(d => d.formType === formType);
    return doc && doc.approvedBy && doc.approvedBy.includes(roleRemark.userId.toString());
  });
};

// Main function to get missing form types that need approval
const getMissingFormTypes = (report, role, ward, userId) => {
  if (role === "Lipik") {
    // For Lipik, check which forms are missing in their documents
    const lipikRemark = report.reportingRemarks.find(r => 
      r.role === role && 
      (r.ward === ward || r.userWard === ward)
    );
    
    if (!lipikRemark || !lipikRemark.documents) {
      return REQUIRED_FORM_TYPES;
    }
    
    const approvedFormTypes = lipikRemark.documents.map(doc => doc.formType);
    return REQUIRED_FORM_TYPES.filter(formType => !approvedFormTypes.includes(formType));
  } else {
    // For other roles, check which Lipik documents they haven't approved
    const lipikRemark = report.reportingRemarks.find(r => r.role === "Lipik");
    
    if (!lipikRemark || !lipikRemark.documents) {
      return REQUIRED_FORM_TYPES;
    }
    
    return REQUIRED_FORM_TYPES.filter(formType => {
      const doc = lipikRemark.documents.find(d => d.formType === formType);
      return !doc || !doc.approvedBy || !doc.approvedBy.includes(userId);
    });
  }
};

exports.addRemarkReports = async (req, res) => {
    try {
        const {
            userId,
            remark,
            role,
            signature,
            ward,
            formType,
            pdfData,
            seleMonth,
            wardName,
            mode
        } = req.body;

        let userWard = ward;

        // Validate required fields
        const missingFields = [];
        if (!role) missingFields.push("role");
        if (!remark) missingFields.push("remark");
        if (!formType) missingFields.push("formType");
        if (!seleMonth) missingFields.push("seleMonth");
        if (!ward) missingFields.push("ward");

        if (missingFields.length > 0) {
            return res.status(400).json({
                message: Missing required fields: ${missingFields.join(", ")}
            });
        }

        // Handle document creation
        const formNumber = await generateFormNumber(formType);
        let document = null;

        if (req.file) {
            document = {
                formType,
                formNumber,
                pdfFile: req.file.path,
                uploadedAt: new Date(),
                seleMonth,
                approvedBy: [] 
            };
        } else if (pdfData) {
            const pdfFilePath = saveBase64File(pdfData, formNumber);
            if (pdfFilePath) {
                document = {
                    formType,
                    formNumber,
                    pdfFile: pdfFilePath,
                    uploadedAt: new Date(),
                    seleMonth,
                    approvedBy: []  
                };
            } else {
                return res.status(400).json({
                    message: "Invalid base64 PDF data."
                });
            }
        } else {
            return res.status(400).json({
                message: "No file or PDF data provided."
            });
        }

        const createRemark = ({ userId, ward, role, remark, signature, document, userWard }) => {
            const remarkObj = {
                userId: new mongoose.Types.ObjectId(userId),
                ward,
                role,
                remark,
                signature,
                userWard,
                date: new Date(),
                documents: []
            };
            
            if (document && role === "Lipik") {
                remarkObj.documents.push(document);
            }

            if (remark === "Approved" && document) {
                document.approvedBy.push(userId);
            }

            if (document && role !== "Lipik") {
                const lipikRemark = report.reportingRemarks.find(r => r.role === "Lipik");

                if (lipikRemark) {
                    lipikRemark.documents = lipikRemark.documents || [];
                    const docIndex = lipikRemark.documents.findIndex(doc => doc.formType === formType);

                    if (mode === "edit") {
                        if (docIndex !== -1) {
                            const existingDoc = lipikRemark.documents[docIndex];
                            const updatedDoc = {
                                ...existingDoc,
                                ...document,
                                uploadedAt: new Date(),
                                signatures: {
                                    ...(existingDoc.signatures || {}),
                                    [role]: signature
                                },
                                approvedBy: existingDoc.approvedBy || []
                            };

                            if (remark === "Approved" && !updatedDoc.approvedBy.includes(userId)) {
                                updatedDoc.approvedBy.push(userId);
                            }

                            lipikRemark.documents[docIndex] = updatedDoc;
                        } else {
                            lipikRemark.documents.push({
                                ...document,
                                uploadedAt: new Date(),
                                signatures: {
                                    [role]: signature
                                },
                                approvedBy: remark === "Approved" ? [userId] : []  
                            });
                        }
                    } else {
                        // Check if document with the same formType already exists
                        const alreadyExists = lipikRemark.documents.some(doc => doc.formType === formType);
                        if (!alreadyExists) {
                            // If not exists, add as a new document (this is the key change)
                            lipikRemark.documents.push({
                                ...document,
                                uploadedAt: new Date(),
                                signatures: {
                                    [role]: signature
                                },
                                approvedBy: remark === "Approved" ? [userId] : []  
                            });
                        } else {
                            // If exists, update the existing document
                            const docIndex = lipikRemark.documents.findIndex(doc => doc.formType === formType);
                            if (docIndex !== -1) {
                                const existingDoc = lipikRemark.documents[docIndex];
                                existingDoc.uploadedAt = new Date();
                                
                                // Update signatures
                                existingDoc.signatures = existingDoc.signatures || {};
                                existingDoc.signatures[role] = signature;
                                
                                // Update approvedBy
                                if (remark === "Approved" && !existingDoc.approvedBy.includes(userId)) {
                                    existingDoc.approvedBy.push(userId);
                                }
                            }
                        }
                    }
                } else {
                    return res.status(400).json({
                        message: "Lipik remark not found. Cannot attach document."
                    });
                }
            }
            return remarkObj;
        };

        // Special handling for Junior Engineer at Head Office
        if (role === "Junior Engineer" && ward === "Head Office" && wardName) {
            let wardReport = await Report.findOne({ seleMonth, ward: wardName });

            if (!wardReport) {
                return res.status(400).json({
                    message: "Report not found for the specified ward."
                });
            }

            // Check if all forms are approved by Ward Junior Engineer
            const wardJEAllFormsApproved = areAllFormsApprovedByRole(wardReport, "Junior Engineer", wardName);
            
            if (!wardJEAllFormsApproved) {
                const missingForms = getMissingFormTypes(wardReport, "Junior Engineer", wardName, userId);
                return res.status(400).json({
                    message: Ward ${wardName} Junior Engineer must approve all forms first. Missing forms: ${missingForms.join(", ")}
                });
            }

            const jeRemark = {
                userId: new mongoose.Types.ObjectId(userId),
                role: "Junior Engineer",
                ward: "Head Office",
                userWard: "Head Office",
                remark,
                signature,
                date: new Date(),
            };

            // Check if Head Office JE already exists
            const jeExists = wardReport.reportingRemarks.some(r =>
                r.userId.toString() === userId &&
                r.role === "Junior Engineer" &&
                (r.ward === "Head Office" || r.userWard === "Head Office")
            );

            if (!jeExists) {
                if (remark === "Approved") {
                    const lipikRemark = wardReport.reportingRemarks.find(r => r.role === "Lipik");
                    if (lipikRemark && lipikRemark.documents?.length > 0) {
                        lipikRemark.documents.forEach(doc => {
                            if (!doc.approvedBy.includes(userId)) {
                                doc.approvedBy.push(userId);
                            }
                        });
                    }
                }

                wardReport.reportingRemarks.push(jeRemark);
                await wardReport.save();
            }

            return res.status(201).json({
                message: Head Office Junior Engineer remark added successfully.,
                report: wardReport
            });
        }

        // Get or create report for the specified ward
        let report = await Report.findOne({ seleMonth, ward });

        if (!report) {
            report = new Report({
                seleMonth,
                ward,
                monthReport: seleMonth,
            });
        }

        // Validate first remark must be from Lipik
        if (report.reportingRemarks.length === 0 && role !== "Lipik") {
            return res.status(400).json({
                message: "The first remark must be from the role 'Lipik'."
            });
        }

        // Workflow validation based on role
        if (role !== "Lipik") {
            if (role === "Junior Engineer" && ward !== "Head Office") {
                // Check if Lipik has approved all forms
                const lipikAllFormsApproved = areAllFormsApprovedByRole(report, "Lipik", ward);
                
                if (!lipikAllFormsApproved) {
                    const missingForms = getMissingFormTypes(report, "Lipik", ward, userId);
                    return res.status(400).json({
                        message: Lipik must approve all forms first. Missing forms: ${missingForms.join(", ")}
                    });
                }
            } else if (role === "Accountant") {
                // Check if Ward JE has approved all forms
                const wardJEAllFormsApproved = areAllFormsApprovedByRole(report, "Junior Engineer", ward);
                
                if (!wardJEAllFormsApproved) {
                    const missingForms = getMissingFormTypes(report, "Junior Engineer", ward, userId);
                    return res.status(400).json({
                        message: Ward Junior Engineer must approve all forms first. Missing forms: ${missingForms.join(", ")}
                    });
                }
                
                // Check if Head Office JE has approved all forms
                const headOfficeJEAllFormsApproved = areAllFormsApprovedByRole(report, "Junior Engineer", "Head Office");
                
                if (!headOfficeJEAllFormsApproved) {
                    const missingForms = getMissingFormTypes(report, "Junior Engineer", "Head Office", userId);
                    return res.status(400).json({
                        message: Head Office Junior Engineer must approve all forms first. Missing forms: ${missingForms.join(", ")}
                    });
                }
            } else if (role === "Assistant Municipal Commissioner") {
                // Check if Accountant has approved all forms
                const accountantAllFormsApproved = areAllFormsApprovedByRole(report, "Accountant", ward);
                
                if (!accountantAllFormsApproved) {
                    const missingForms = getMissingFormTypes(report, "Accountant", ward, userId);
                    return res.status(400).json({
                        message: Accountant must approve all forms first. Missing forms: ${missingForms.join(", ")}
                    });
                }
            } else if (role === "Dy.Municipal Commissioner") {
                // Check if Assistant Municipal Commissioner has approved all forms
                const amcAllFormsApproved = areAllFormsApprovedByRole(report, "Assistant Municipal Commissioner", ward);
                
                if (!amcAllFormsApproved) {
                    const missingForms = getMissingFormTypes(report, "Assistant Municipal Commissioner", ward, userId);
                    return res.status(400).json({
                        message: Assistant Municipal Commissioner must approve all forms first. Missing forms: ${missingForms.join(", ")}
                    });
                }
            }
        }

        // Update existing remark or create a new one
        const index = report.reportingRemarks.findIndex(r =>
            r.userId.toString() === userId &&
            r.role === role &&
            (r.ward === ward || r.userWard === ward)
        );

        if (index !== -1) {
            const existing = report.reportingRemarks[index];
            existing.remark = remark;
            existing.signature = signature;
            existing.date = new Date();
            
            // Handle documents for Lipik role
            if (role === "Lipik") {
                existing.documents = existing.documents || [];
                const docIndex = existing.documents.findIndex(doc => doc.formType === formType);
                
                if (docIndex !== -1) {
                    // Update existing document of the same type
                    const existingDoc = existing.documents[docIndex];
                    existingDoc.uploadedAt = new Date();
                    existingDoc.pdfFile = document.pdfFile;
                    
                    // Reset approvals if document is updated
                    if (mode === "edit") {
                        existingDoc.approvedBy = [userId];
                    }
                } else {
                    // Add new document with different formType
                    existing.documents.push({
                        ...document,
                        uploadedAt: new Date(),
                        approvedBy: [userId]
                    });
                }
            }

            if (remark === "Approved") {
                const lipikRemark = report.reportingRemarks.find(r => r.role === "Lipik");
                if (lipikRemark && lipikRemark.documents?.length > 0) {
                    lipikRemark.documents.forEach(doc => {
                        if (!doc.approvedBy.includes(userId)) {
                            doc.approvedBy.push(userId);
                        }
                    });
                }
            }

            report.reportingRemarks[index] = existing;
        } else {
            const newRemark = createRemark({ userId, role, ward, remark, signature, document, userWard });
            report.reportingRemarks.push(newRemark);
        }

        await report.save();

        res.status(201).json({
            message: "Report added/updated successfully.",
            report
        });

    } catch (error) {
        console.error("🚨 Error adding/updating report:", error);
        res.status(500).json({
            message: "An error occurred while adding the report.",
            error: error.message
        });
    }
};
---------------
BASEURL=http://localhost:5000
API=http://localhost:5000

=====================
BASEURL=http://localhost:5000
API=http://localhost:5000

BASEURL=https://lightbillbackend.saavi.co.in
API=https://lightbillbackend.saavi.co.in

BASEURL=http://localhost:5000
API=http://localhost:5000

-------------------------------------------------
BASEURL=http://localhost:5000
API=http://localhost:5000
---------------------------------------------------------

BASEURL=https://lightbillbackend.saavi.co.in
API=https://lightbillbackend.saavi.co.in
AAPPASSWORD=enpz swmp tycr ryhh 
BASEURLEMAIL=https://lightbillbackend.saavi.co.in

-----------------------------------------------

BASEURL=https://lightbillbackend.saavi.co.in
API=https://lightbillbackend.saavi.co.in
BASEURLEMAIL=https://lightbillbackend.saavi.co.in

===================
 BASEURL=https://lightbillbackend.onrender.com
 API=https://lightbillbackend.onrender.com
BASEURLEMAIL=https://lightbillbackend.onrender.com

======================
BASEURL=https://lightbillbackend.saavi.co.in
API=https://lightbillbackend.saavi.co.in
===========================
BASEURL=https://lightbillbackend.saavi.co.in
API=https://lightbillbackend.saavi.co.in
BASEURLEMAIL=https://lightbillbackend.saavi.co.in
===================================================
 BASEURL=https://lightbillbackend.onrender.com
 API=https://lightbillbackend.onrender.com
BASEURLEMAIL=https://lightbillbackend.onrender.com
-------------------------
BASEURL=https://lightbillbackend.saavi.co.in
API=https://lightbillbackend.saavi.co.in
BASEURLEMAIL=https://lightbillbackend.saavi.co.in